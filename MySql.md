## MySql

- [为什么 MySQL 使用 B+树作为索引的数据结构？](#1)
- [关系型和非关系型数据库的区别（各自优点）](#2)
- [什么是索引](#3)
- [数据库的索引类型](#4)
- [聚集索引和非聚集索引的区别（叶节点存储内容）](#5)
- [唯一性索引和主键索引的区别](#6)
- [什么是事务](#7)
- [事务的四大特性](#8)
- [事务并发会带来什么问题](#9)
- [事务的四大隔离级别](#10)
- [MySql 如何实现事务隔离](#11)
- [MySql 锁机制](#12)
- [表锁与行锁的区别](#13)
- [InnoDB 如何避免幻读](#14)
- [MyISAM 和 InnoDB 的区别](#15)
- [什么是索引的最左前缀原则](#16)

<h3 id="1">为什么MySQL使用B+树作为索引的数据结构？</h3>

---

哈希表，红黑树，B 树，B+树的区别：

1. 哈希表：哈希表的数据存储是无序的，对于单条数据查找有优势，对于范围查找需要全表扫描，这将非常糟糕。
2. 红黑树：高度平衡的二叉查找树，红黑树的所有规则都是为了保持平衡，而且子节点只能有两个，我们知道树的高度与磁盘 io 的次数成正比，所以数据量大的话，红黑树就没有任何优势。
3. B 树：B 树是儿茶平衡树的变种，不同的是 B 树的子节点是多路的，可以收缩树的高度。
4. B+树：B+树是 B 树的变种，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历，相比于 B 树，B+树去掉了内节点去掉了 data 域，因此有更大的出度，有更好的性能。

另一方面，在磁盘存储上，B 树和 B+树有着天然的优势，内存和磁盘的数据交换不是以字节为单位的，而是以 N 个扇区(一个扇区为 512 字节)为单位，一般为 8 个扇区(4KB)为单位。而 B 树和 B+树可以将每个节点设置为 4KB 大小， 那么读取一个节点只需要一次磁盘 IO，大大提高了效率。

<h3 id="2">关系型和非关系型数据库的区别（各自优点）</h3>

---

关系型数据库是简单的表结构  
优点：易于维护，使用方便，直接用 sql 语句进行查询，支持复杂的多表的连接查询。  
缺点：读写性能差，尤其是面对海量数据的高效率读写；固定的表结构，灵活性差；高并发读写需求，面临硬盘 I/O 的瓶颈。
非关系型数据库：（包括四种：键值存储数据库 Redis，列存储数据库 HBase，文档数据库 MongoDB CoachDB，图形数据库 IinforGrid）
优点：格式灵活，支持以上四种格式；速度快；扩展性好；容易部署。  
缺点：不支持事务，不支持 sql，不利于对复杂的查询。

<h3 id="3">什么是索引</h3>

---

索引是帮助数据库高效获取数据的排好序的数据结构。

<h3 id="4">数据库的索引类型</h3>

---

- 唯一索引：每一个索引对应唯一的数据记录
- 主键索引：以主键作为索引
- 聚集索引：索引的顺序和数据存储的物理顺序是相同的

<h3 id="5">聚集索引和非聚集索引的区别（叶节点存储内容）</h3>

---

- 聚集索引：表数据按照索引的顺序存储，索引的顺序和表中记录的物理顺序一致。叶子节点存储了真实的数据行，不再有另外单独的数据页。（类似于新华字典中按照拼音目录（字母+声调））一张表中最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。
- 非聚集索引：索引的逻辑顺序和数据存储的物理顺序无关（类似于新华字典中的偏旁目录），叶子节点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

<h3 id="6">唯一性索引和主键索引的区别</h3>

---

- 主键索引只能创建一个，唯一索引可以创建多个
- 主键索引列不能是空值，唯一索引列可以为空值
- 主键索引严格来讲就是表的主键，是一种约束；唯一索引是一种索引，它是一种数据结构，二者有本质的差别
- 主键索引可以作为其他表的外键，而唯一索引不可以
- 主键一定会创建一个唯一索引，但有唯一索引的列不一定是主键

<h3 id="7">什么是事务</h3>

---

事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

<h3 id="8">事务的四大特性</h3>

---

- 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- 一致性（Consistency）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durablity）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

<h3 id="9">事务并发会带来什么问题</h3>

---

- 脏读：A 事务执行过程中，B 事务读取了 A 事务的修改。但是由于某些原因，A 事务可能没有完成提交，发生 RollBack 了操作，则 B 事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。
- 不可重复读：B 事务读取了两次数据，在这两次的读取过程中 A 事务修改了数据，B 事务的这两次读取出来的数据不一样。B 事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。
- 幻读：B 事务读取了两次数据，在这两次的读取过程中 A 事务添加了数据，B 事务的这两次读取出来的集合不一样。

<h3 id="10">事务的四大隔离级别</h3>

---

| 事务隔离级别                 | 脏读   | 不可重复读 | 幻读   |
| ---------------------------- | ------ | ---------- | ------ |
| 读未提交（READ UNCOMMITTED） | 可能   | 可能       | 可能   |
| 读已提交（READ COMMITTED）   | 不可能 | 可能       | 可能   |
| 可重复读（REPEATABLE READ）  | 不可能 | 不可能     | 可能   |
| 串行化（SERIALIZABLE）       | 不可能 | 不可能     | 不可能 |

<h3 id="11">MySql 如何实现事务隔离</h3>

---

1. 在读取数据前，对其加锁，阻止其它事务对数据进行修改一一 Lock Based Concurrency Control(LBCC)
2. 生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取一一 Multi Version Concurrency Control(MVCC)

<h3 id="12">MySql 锁机制</h3>

---

锁的粒度：`表级锁`、`行级锁`、`页级锁`。  
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

**行级锁：**

**共享锁与排他锁（Shared and Exclusive Locks）：**

- 共享锁（读锁、S 锁）：其他事务可以读，但不能写。

  - 加锁方式：`SELECT ... LOCK IN SHARE MODE`。
  - 释放锁：`commit/rollback`。

- 排他锁（写锁、X 锁） ：其他事务不能读取，也不能写。

  - 加锁方式：

    - 自动：`delete / update / insert` 默认加上 X 锁。
    - 手动：`SELECT ... FOR UPDATE`。

  - 释放锁：`commit/rollback`。

**表级锁：**

**意向锁：** 意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，提高加表锁的效率。

1. 意向共享锁（Intention Shared Lock，简称 IS 锁）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。
2. 意向排他锁（Intention Exclusive Lock，简称 IX 锁）：表示事务准备给数据行加入排他锁，说明事务在一个数据加排他锁钱必须先取得该表的 IX 锁。

<h3 id="13">表锁与行锁的区别</h3>

---

MyISAM 支持表锁。
InnoDB 既支持表锁也支持行锁。

1. 锁定粒度：表锁 > 行锁。
2. 加锁效率：表锁 > 行锁。
3. 冲突概率：表锁 > 行锁。
4. 并发性能：表锁 < 行锁。

<h3 id="14">InnoDB 如何避免幻读</h3>

---

MySQL InnoDB 支持三种行锁定方式：

- 记录锁（Record Lock）：单个行记录上的锁。
- 间隙锁（Gap Lock）：间隙锁，锁定一个范围，但不包括记录本身。GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。
- 临键锁（Next-Key Lock）：记录锁和间隙锁组合起来就叫 Next-Key Lock，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

<h3 id="15">MyISAM 和 InnoDB 的区别</h3>

---

1. InnoDB 支持事务；MyISAM 不支持。
2. InnoDB 支持外键；MyISAM 不支持。
3. InnoDB 是聚集索引；MyISAM 是非聚集索引。
4. InnoDB 不保存表的具体行数，执行 `select count(*) from table` 时需要全表扫描；MyISAM 用一个变量保存了表的行数。
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。
6. InnoDB 如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值；MyISAM 允许没有任何索引和主键的表存在，索引都是保存行的地址。

<h3 id="16">什么是索引的最左前缀原则</h3>

---

MySql 建立多列索引（联合索引）有最左前缀的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
