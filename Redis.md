# Redis

- [Redis 的缓存穿透，缓存击穿和雪崩和解决方法](#1)
- [Redis 的高可用方案](#2)
- [Redis 的数据类型及底层实现](#3)
- [Redis 的 ZSet 为什么用跳跃表不用红黑树](#4)
- [Redis 的持久化方式及区别](#5)
- [Redis 是多线程还是单线程架构](#6)
- [Redis 为什么这么快](#7)

<h3 id="1">Redis 的缓存穿透，缓存击穿和雪崩和解决方法</h3>

---

缓存穿透：缓存和数据库中都没有的数据，而用户不断发起请求，造成 Redis 和数据库压力大。  
缓存击穿：缓存中没有数据（或者缓存过期）但数据库中有数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。  
雪崩：同一时间有大量的缓存过期，或者 Redis 挂了，将会有大量的请求到数据库中，造成数据库压力过大而挂掉。

**解决方法：**  
缓存穿透：

1. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击。
2. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。

缓存击穿：

1. 设置布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
2. 如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个结果进行缓存，但是它的过期时间会很短，最长不超过 5 分钟。
3. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。

雪崩：

1. 设置 redis 集群和 DB 集群的高可用，如果 redis 出现宕机情况，可以立即由别的机器顶替上来。这样可以防止一部分的风险。
2. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。
3. 不同的 key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。
4. 永远不过期。redis 中设置永久不过期，这样就保证了，不会出现热点问题，也就是物理上不过期。

<h3 id="2">Redis 的高可用方案</h3>

---

1. 主从模式：
   原理：
   Slave 从节点服务启动并连接到 Master 之后，它将主动发送一个 SYNC 命令。Master 服务主节点收到同步命令后将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master 将传送整个数据库文件到 Slave，以完成一次完全同步。而 Slave 从节点服务在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master 主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给 slaves，slave 将在本次执行这些数据修改命令，从而达到最终的数据同步。  
   优点：

   - 高可靠性：一方面，采用双击主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。
   - 读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。

   缺点：

   - 故障恢复复杂，如果没有 Redis 高可用（HA）系统，当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。
   - 主库的写能力受到单机的限制，可以考虑分片。
   - 主库的存储能力受到单机的限制。
   - 原生复制的弊端在早期的版本中也会比价突出，如：Redis 复制中断后，Slave 会发起 psync ，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。

2. 哨兵模式（Sentinel）：
   原理：
   Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。
   其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现，故障自动转移，配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n + 1 （n>=1）的奇数个。  
   优点：

   - 哨兵集群，基于主从复制模式，所有的主从配置优点，它都有
   - 主从可以切换，故障可以转移，高可用性的系统
   - 哨兵模式就是主从模式的升级，手动到自动，更加健壮

   缺点：

   - Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦
   - 哨兵模式的配置繁琐

3. 集群（Cluster）：
   原理：
   Redis 集群方案采用分而治之的思想。Redis 集群预先分配好 16384 个 slot（哈希槽），每个 Master 节点负责处理 16384 个 slot 中的一部分，当需要在 Redis 集群中写入一个 key-value 时，会使用 key 映射的一致性算法：`hash_slot = CRC16(key) mod 16383` 来决定将 key 写入哪一个槽位从而决定写入到哪一个 Master 节点上。  
   Redis 的所有节点都是互联（PING-PONG 机制）的，所以客户端可以任意连接集群中的某一个 Redis 节点，节点计算出 hash_slot 后，会向负责该槽的 redis 进行请求。
   Redis 集群的扩容和缩容只需要移动一部分 slot 即可，移动 slot 的代价是很小的。
   Redis 集群的高可用原理几乎与哨兵模式是类似的。
   优点：

   - 无中心架构；
   - 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；
   - 可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；
   - 高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；
   - 降低运维成本，提高系统的扩展性和可用性。

   缺点：

   - Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。
   - 节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。
   - 数据通过异步复制，不保证数据的强一致性。
   - 多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。
   - Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。
   - Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。
   - Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。
   - Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。
   - 不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0 。
   - 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。
   - 避免产生 hot-key，导致主库节点成为系统的短板。
   - 避免产生 big-key，导致网卡撑爆、慢查询等。
   - 重试时间应该大于 cluster-node-time 时间。
   - Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。

<h3 id="3">Redis 的数据类型及底层实现</h3>

---

| 类型   | 底层编码实现                                            |
| ------ | ------------------------------------------------------- |
| String | OBJ_ENCODING_RAW, OBJ_ENCODING_INT, OBJ_ENCODING_EMBSTR |
| List   | OBJ_ENCODING_QUICKLIST                                  |
| Set    | OBJ_ENCODING_INTSET ,OBJ_ENCODING_HT                    |
| ZSet   | OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_SKIPLIST             |
| Hash   | OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_HT                   |

编码解释：

- OBJ_ENCODING_RAW：SDS，Redis 实现的简单动态字符串。
- OBJ_ENCODING_INT：int 整型。
- OBJ_ENCODING_EMBSTR：SDS。
- OBJ_ENCODING_QUICKLIST：快速列表，由 adlist（双端链表）与 ziplist（压缩列表）构成。
- OBJ_ENCODING_INTSET：整数集合。
- OBJ_ENCODING_HT：哈希表。
- OBJ_ENCODING_ZIPLIST：压缩列表。
- OBJ_ENCODING_SKIPLIST：跳跃表。

使用何种编码选择：

- String：当数据长度小与 44 时，用 OBJ_ENCODING_EMBSTR 编码，否则使用 OBJ_ENCODING_RAW 编码。如果一个字符串对象保存的是整数值，并且可以用 long 类型来表示，则将字符串对象转为 long，设置编码类型为 OBJ_ENCODING_INT。
- Set：使用 OBJ_ENCODING_INTSET 的条件：

  - 集合对象中所有元素都是整数值。
  - 集合对象保存的元素个数不超过 512 个。（可通过 redis.conf 配置：set_max_intset_entries）

- ZSet：使用 OBJ_ENCODING_ZIPLIST 的条件：

  - 有序集合对象中所有元素的大小都小于 64 字节。（可通过 redis.conf 配置：zset_max_ziplist_value）
  - 有序集合对象保存的元素个数不超过 128 个。（可通过 redis.conf 配置：zset_max_ziplist_entries）

- Hash：使用 OBJ_ENCODING_ZIPLIST 的条件：

  - hash 对象保存的键值对的键和值的字符串长度小于 64 字节（可通过 redis.conf 配置：hash_max_ziplist_value）
  - hash 对象保存的键值对数小于 512 个（可通过 redis.conf 配置：hash_max_ziplist_entries）

<h3 id="4">Redis 的 ZSet 为什么用跳跃表不用红黑树</h3>

---

| 区别     | 跳跃表                           | 红黑树   |
| -------- | -------------------------------- | -------- |
| 内存     | 大（每个数据都需要维护多层指针） | 小       |
| 效率     | O(logn)                          | O(logn)  |
| 存储方式 | 有序存储                         | 无序存储 |

因为 ZSet 需要支持范围查询，所以使用跳跃表。

<h3 id="5">Redis 的持久化方式及区别</h3>

---

Redis 支持两种持久化方式：AOF 和 RDB（默认）。

- AOF：通过保存 Redis 所执行的写命令来记录数据库状态的。
- RDB：在指定的时间间隔内将内存中的数据集快照写入到二进制文件中，Redis 会派生出一个子进程，然后由子进程负责创建 RDB 文件并写入，父进程继续处理命令请求。

区别：

- RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每 6 小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。
- Redis 加载 RDB 恢复数据远远快于 AOF 的方式。
- RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。

<h3 id="6">Redis 是多线程还是单线程架构</h3>

---

单线程。

<h3 id="7">Redis 为什么这么快</h3>

---

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
- 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的。
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。
- 使用多路 I/O 复用模型，非阻塞 IO。
