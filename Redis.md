## Redis

- [Redis 的缓存穿透，缓存击穿和雪崩和解决方法](#1)
- [Redis 的高可用方案](#2)

<h3 id="1">Redis的缓存穿透，缓存击穿和雪崩和解决方法</h3>

---

缓存穿透：缓存和数据库中都没有的数据，而用户不断发起请求，造成 Redis 和数据库压力大。  
缓存击穿：缓存中没有数据（或者缓存过期）但数据库中有数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。  
雪崩：同一时间有大量的缓存过期，或者 Redis 挂了，将会有大量的请求到数据库中，造成数据库压力过大而挂掉。

**解决方法：**  
缓存穿透：

1. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击。
2. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。

缓存击穿：

1. 设置布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
2. 如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个结果进行缓存，但是它的过期时间会很短，最长不超过 5 分钟。
3. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。

雪崩：

1. 设置 redis 集群和 DB 集群的高可用，如果 redis 出现宕机情况，可以立即由别的机器顶替上来。这样可以防止一部分的风险。
2. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。
3. 不同的 key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。
4. 永远不过期。redis 中设置永久不过期，这样就保证了，不会出现热点问题，也就是物理上不过期。

<h3 id="2">Redis的高可用方案</h3>

---

1. 主从模式：
   原理：
   优点：
   缺点：
2. 哨兵模式：
   原理：
   优点：
   缺点：
3. 集群：
   原理：
   优点：
   缺点：
