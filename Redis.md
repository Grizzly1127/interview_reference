## Redis

- [Redis 的缓存穿透，缓存击穿和雪崩和解决方法](#1)
- [Redis 的高可用方案](#2)

<h3 id="1">Redis的缓存穿透，缓存击穿和雪崩和解决方法</h3>

---

缓存穿透：缓存和数据库中都没有的数据，而用户不断发起请求，造成 Redis 和数据库压力大。  
缓存击穿：缓存中没有数据（或者缓存过期）但数据库中有数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。  
雪崩：同一时间有大量的缓存过期，或者 Redis 挂了，将会有大量的请求到数据库中，造成数据库压力过大而挂掉。

**解决方法：**  
缓存穿透：

1. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击。
2. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。

缓存击穿：

1. 设置布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
2. 如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个结果进行缓存，但是它的过期时间会很短，最长不超过 5 分钟。
3. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。

雪崩：

1. 设置 redis 集群和 DB 集群的高可用，如果 redis 出现宕机情况，可以立即由别的机器顶替上来。这样可以防止一部分的风险。
2. 使用互斥锁。在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用 synchronized 或者 lock 来解决，如果是分布式环境，可以是用 redis 的 setnx 命令来解决。
3. 不同的 key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。
4. 永远不过期。redis 中设置永久不过期，这样就保证了，不会出现热点问题，也就是物理上不过期。

<h3 id="2">Redis的高可用方案</h3>

---

1. 主从模式：
   原理：
   Slave 从节点服务启动并连接到 Master 之后，它将主动发送一个 SYNC 命令。Master 服务主节点收到同步命令后将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master 将传送整个数据库文件到 Slave，以完成一次完全同步。而 Slave 从节点服务在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master 主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给 slaves，slave 将在本次执行这些数据修改命令，从而达到最终的数据同步。  
   优点：

   - 高可靠性：一方面，采用双击主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。
   - 读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。

   缺点：

   - 故障恢复复杂，如果没有 Redis 高可用（HA）系统，当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。
   - 主库的写能力受到单机的限制，可以考虑分片。
   - 主库的存储能力受到单机的限制。
   - 原生复制的弊端在早期的版本中也会比价突出，如：Redis 复制中断后，Slave 会发起 psync ，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。

2. 哨兵模式（Sentinel）：
   原理：
   Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。
   其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现，故障自动转移，配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n + 1 （n>=1）的奇数个。  
   优点：

   - 哨兵集群，基于主从复制模式，所有的主从配置优点，它都有
   - 主从可以切换，故障可以转移，高可用性的系统
   - 哨兵模式就是主从模式的升级，手动到自动，更加健壮

   缺点：

   - Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦
   - 哨兵模式的配置繁琐

3. 集群（Cluster）：
   原理：
   Redis 集群方案采用分而治之的思想。Redis 集群预先分配好 16384 个 slot（哈希槽），每个 Master 节点负责处理 16384 个 slot 中的一部分，当需要在 Redis 集群中写入一个 key-value 时，会使用 key 映射的一致性算法：`hash_slot = CRC16(key) mod 16383` 来决定将 key 写入哪一个槽位从而决定写入到哪一个 Master 节点上。  
   Redis 的所有节点都是互联（PING-PONG 机制）的，所以客户端可以任意连接集群中的某一个 Redis 节点，节点计算出 hash_slot 后，会向负责该槽的 redis 进行请求。
   Redis 集群的扩容和缩容只需要移动一部分 slot 即可，移动 slot 的代价是很小的。
   Redis 集群的高可用原理几乎与哨兵模式是类似的。
   优点：

   - 无中心架构；
   - 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；
   - 可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；
   - 高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；
   - 降低运维成本，提高系统的扩展性和可用性。

   缺点：

   - Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。
   - 节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。
   - 数据通过异步复制，不保证数据的强一致性。
   - 多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。
   - Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。
   - Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。
   - Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。
   - Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。
   - 不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0 。
   - 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。
   - 避免产生 hot-key，导致主库节点成为系统的短板。
   - 避免产生 big-key，导致网卡撑爆、慢查询等。
   - 重试时间应该大于 cluster-node-time 时间。
   - Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。
