## 操作系统

- [什么是死锁，怎么避免](#1)
- [进程间通信方式有哪些](#2)
- [线程同步的方式](#3)
- [linux 755 指的是什么权限](#4)
- [系统调用和函数调用的区别](#5)
- [静态库和动态库的区别](#6)
- [什么是虚拟内存](#7)
- [一台只有 2G 物理内存的电脑，能否 new 一个 4G 大小的数组](#8)
- [孤儿进程、僵尸进程、守护进程的概念](#9)
- [多进程和多线程的区别](#10)
- [如何创建守护进程](#11)
- [内核态，用户态的区别](#12)
- [进程切换的过程](#13)

<h3 id="1">什么是死锁，怎么避免</h3>

---

死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。  
产生死锁的四个必要条件：

1. 互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放
2. 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4. 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

避免死锁：

1. 避免多次锁定。
2. 具有相同的加锁顺序。
3. 使用定时锁。
4. 死锁检测。

<h3 id="2">进程间通信方式有哪些</h3>

---

1. 无名管道：半双工，只能用于亲缘进程。
2. 有名管道：半双工，可以用于无亲缘关系进程。
3. 消息队列：是消息的链表，存放在内核中。一个消息队列由一个标识符来标识。
4. 共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
5. 信号：用于通知接收进程某个事件发生。
6. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
7. 套接字 socket：可用于不同机器间进程的通信。

<h3 id="3">线程同步的方式</h3>

---

1. 互斥锁（mutex）。
2. 条件变量（condition）。
3. 读写锁（rwlock）。
4. 信号量（sem）。

<h3 id="4">linux 755 指的是什么权限</h3>

---

在 Linux 系统中，文件或目录权限如下：  
文件：-rwxrwxrwx  
目录：drwxrwxrwx  
"-" 表示文件，"d" 表示目录。  
第一个 rwx 表示：文件拥有者（用户）权限  
第二个 rwx 表示：文件所在组的权限  
第三个 rwx 表示：其他用户对此文件的权限

其中 rwx 的含义如下：  
`r：4 读` `w：2 写` `x：1 执行(运行)` `-：0 无任何权限`  
数字 4 、2 和 1 表示读、写、执行权限  
rwx = 4 + 2 + 1 = 7 (可读写运行）  
rw = 4 + 2 = 6 （可读写不可运行）  
rx = 4 +1 = 5 （可读可运行不可写）

所以 755 表示：  
第一个 7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限  
第二个 5:表示当前文件的所属组（同组用户）权限,5=4+1 可读可执行权限  
第三个 5:表示当前文件的组外权限,5=4+1 可读可执行权限

<h3 id="5">系统调用和函数调用的区别</h3>

---

系统调用：是操作系统内核提供的函数，在内核态运行，是操作系统为用户提供的一些接口。它通过软中断向内核态发出一个明确的请求。有一些任务需要进程跑在内核态才能执行，比如和硬件打交道。所以进程调用系统调用就能让自己运行在内核态从而执行这些类似的任务。

区别：  
系统调用:

1. 使用 INT 和 IRET 指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备
2. 依赖于内核，不保证移植性
3. 在用户空间和内核上下文环境间切换，开销较大
4. 是操作系统的一个入口点

函数调用:

1. 使用 CALL 和 RET 指令，调用时没有堆栈切换
2. 平台移植性好
3. 属于过程调用，调用开销较小
4. 一个普通功能函数的调用

<h3 id="6">静态库和动态库的区别</h3>

---

静态链接:

**优点：**

1. 因为可执行程序中已经具备了执行程序所需要的所有东西，所以程序加载速度快，执行速度也快。
2. 只需要保证开发者计算机上有正确的 .a 文件，在发布可执行程序时，不需要考虑发布机器上是否存在 .a 文件。

**缺点：**

1. 使用静态链接生成的可执行文件体积较大，包含了相同的公共代码，造成空间浪费。
2. 更新困难，如果静态库文件更新，需要重新编译链接整个可执行文件，再行发布。

动态链接:

为了解决静态链接的缺点，就需要使用到动态链接。
在 Linux 中，动态链接库以 .so 为文件后缀。
动态链接的思想就是将程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成完整的程序。
![mem](https://qqadapt.qpic.cn/txdocpic/0/4f8013511ac6fbf141ebdfe1a1d065aa/0)
**优点：**

1. 更加节省内存并减少页面交换。
2. 更新方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。
3. 可是实现进程之间的资源共享。

**缺点：**

1. 当某个动态库更新后，如果依赖该动态库的程序与更新后的动态库不兼容，则该程序将无法正常执行。
2. 因为是运行时加载，所以相对于静态链接，性能会有所下降。

<h3 id="7">什么是虚拟内存</h3>

---

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。

<h3 id="8">一台只有 2G 物理内存的电脑，能否 new 一个 4G 大小的数组</h3>

---

在 32 位平台下，虚拟内存最大的寻址空间为 2 ^ 32 = 4G，所以最大支持的 4G 的虚拟内存，而在这 4G 中，内核需要占用大概 1G 左右的共享内存空间，剩下的 3G 用户空间不足以 new 一个 4G 大小的数组。
在 64 位平台下，最大支持 2 ^ 64 = 16TB 的虚拟内存空间，是可以 new 一个 4G 大小的数组的。

<h3 id="9">孤儿进程、僵尸进程、守护进程的概念</h3>

---

孤儿进程：父进程退出，子进程还在运行，那么这些子进程就是孤儿进程，孤儿进程由操作系统的 1 号进程接管和处理。  
僵尸进程：子进程结束之后，父进程结束之前，这个阶段，子进程是 僵尸进程。但是如果父进程是一个循环，子进程 就会 一直保持 僵尸状态。僵尸进程会一直占用进程号。  
守护进程：也称为精灵进程是一种生存期较长的一种进程。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。他们常常在系统引导装入时启动，在系统关闭时终止。unix 系统有很多守护进程，大多数服务器都是用守护进程实现的。

<h3 id="10">多进程和多线程的区别</h3>

---

1. 多进程之间是内存隔离的，每个进程都有自己的内存空间；同个进程的多线程之间共享数据，但是线程有自己的栈空间。
2. 线程切换速度快，需要保存的上下文资源少，进程切换速度慢，需要保存的上下文资源多。
3. 子进程的创建需要拷贝父进程堆栈和数据空间，创建开销大。

<h3 id="11">如何创建守护进程</h3>

---

守护进程编程步骤：

1. 创建子进程，父进程退出
   - 所有工作在子进程中进行
   - 形式上脱离了控制终端
2. 在子进程中创建新会话
   - setsid()函数
   - 使子进程完全独立出来，脱离控制
3. 改变当前目录为根目录
   - chdir()函数
   - 防止占用可卸载的文件系统
   - 也可以换成其它路径
4. 重设文件权限掩码
   - umask()函数
   - 防止继承的文件创建屏蔽字拒绝某些权限
   - 增加守护进程灵活性
5. 关闭文件描述符
   - 继承的打开文件不会用到，浪费系统资源，无法卸载
   - getdtablesize()
   - 返回所在进程的文件描述符表的项数，即该进程打开的文件数目

<h3 id="12">内核态，用户态的区别</h3>

---

现代 CPU，其设计目标主要是为了完美高效的实现一个多任务系统，多任务系统的三个核心特征是：权限分级、数据隔离和任务切换。有了 CPU 的特权级别（intel cpu 从 R0-R3 四个特级级别，R0 最高），为了安全，操作系统也将执行状态分成了内核态和用户态，同时利用上 CPU 特权特性，将内核态时的 CPU 特别级置为 R0，用户态的 CPU 特权级置为 R3。  
内核本质上看是一种软件，是控制计算机的硬件资源，并提供上层应用程序运行的环境。  
用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括 CPU 资源、存储资源、I/O 资源等。

<h3 id="13">进程切换的过程</h3>

---

(1). A 的用户态-->A 的内核态：这一过程是由中断，异常或系统调用实现的。每次从用户态切换到内核态，内核栈都会被清空，ESP 直接指向内核栈的栈底，而用户栈的信息则会保存到内核栈中。空内核栈的设计估计是考虑到经过了用户态的操作后，以前内核栈的调用信息没有用处了，没有必要再保存，毕竟内核栈只分配了 8K 或 4K 的空间。那么，切换到内核态之前，内核怎么知道进程的内核栈地址呢，进程描述符虽然保存有内核栈的地址（stack 变量），但是进程描述符位于动态内态中，从内存读取的效率太低了。实现上，它是从 TSS 中获取的。  
每个 CPU 都有一个 TSS，CPU 可以快速访问它。TSS 的一个最重要的功能就是在用户态转为内核态时供 CPU 读取内核栈地址，即是 init_tss[cpu]->sp0 字段，实际上，它存储的是栈底地址，因此一加载到 ESP 中，就同时清空了内核栈。

(2). A 的内核态-->B 的内核态：这一阶段实现的是进程间的内核栈切换，同时也实现进程切换。与此过程关系最密切的是 task_struct 的 thread 变量，thread 变量的类型是 thread_struct，可称为线程描述符，用于保存进程切换的硬件上下文（书中第 109 页）。书中的 switch_to 和\*\*switch_to 函数详细描述了进程切换过程中的每一个步骤，与内核栈相关的有：

- 保存 A 的内核栈栈顶地址，即 ESP 寄存器的内容到 A_task->thread->sp。（switch_to 的第 3 步,变量名根据 3.2.54 版本中的代码）
- 将 B_task->thread->sp 内容加载到 ESP。(switch_to 的第 4 步，这步完成了内核栈的切换)
- 将 B_task->thread->sp0 加载到 init_tss[cpu]->sp0 字段（\*\*switch_to 的第 3 步），这一步与(1)的描述对应，以后 B 在运行期间，用户态切换到内核态时，ESP 寄存器总是从 init_tss[cpu]->sp0 字段获取内核栈的地址，这一操作同时清空了内核栈内容。（thread_struct 结构有 sp0，sp1 变量，sp0 保存内核栈栈底地址，sp 保存栈顶地址）。

(3). B 的内核态-->B 的用户态：执行与 (1) 相反的过程，从内核栈中取出（1）中保存的用户栈信息，装载相应寄存器，切换到用户栈，内核栈信息不必保存，因为 (2) 中已保存了栈底地址，下次进入内核栈时直接将其加载到 ESP 寄存器中即可（将栈底地址作为栈顶使用）。
