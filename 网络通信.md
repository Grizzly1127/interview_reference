## 网络通信

- [tcp 和 udp 的区别](#1)
- [如何实现基于 udp 的可靠协议](#2)
- [tcp, udp 是那一层的协议](#3)
- [tcp 怎么保证可靠性](#4)
- [tcp 的停止等待协议是什么](#5)
- [三次握手和四次挥手](#6)
- [可以是两次握手吗](#7)
- [为什么要 timewait，timewait 有什么缺点](#8)
- [滑动窗口的原理](#9)
- [网线断开会发生什么，哪一端会先断开](#10)
- [tcp 最大连接数限制](#11)
- [什么是 tcp 粘包，怎么解决](#12)

<h3 id="1">tcp 和 udp 的区别</h3>

---

|              | tcp                                  | udp                      |
| ------------ | ------------------------------------ | ------------------------ |
| 是否连接     | 无连接                               | 面向连接                 |
| 是否可靠     | 不可靠传输，不是用流量控制和拥塞控制 | 可靠传输                 |
| 连接对象个数 | 支持 N 对 N 通信                     | 只支持 1 对 1 通信       |
| 传输方式     | 面向报文                             | 面向字节流               |
| 首部开销     | 8 字节                               | 20 ~ 60 字节             |
| 适用场景     | 适用与实时应用                       | 适用与需要可靠传输的应用 |

<h3 id="2">如何实现基于 udp 的可靠协议</h3>

---

1. 增加确认机制，接收方收到 udp 包后回复个确认包。
2. 发送方增加超时重传机制，当包发送出去后，没有得到接收方确认包，就需要重新发送该包。
3. 增加滑动窗口，当网络太差频繁丢包时，防止越丢包越重传的恶性循环，要有个发送窗口的限制，窗口大小根据网络状况使用相应的调整算法来适应。

<h3 id="3">tcp, udp 是那一层的协议</h3>

---

传输层。

<h3 id="4">tcp 怎么保证可靠性</h3>

---

1. 建立连接需要三次握手，断开连接需要四次挥手。
2. 超时重传机制。
3. TCP 包的校验和。
4. 序列号和确认应答。
5. 流量控制。
6. 拥塞控制（慢启动，拥塞避免，快重传，快恢复）。

<h3 id="5">tcp 的停止等待协议是什么</h3>

---

发送方每发送完一个分组就停止发送，等待接收方的确认应答，在收到确认应答后再发送下一个分组。

<h3 id="6">三次握手和四次挥手</h3>

---

三次握手:

![net_hand-shaking](image/net_hand-shaking.png)

四次挥手：

![net_wave.png](image/net_wave.png)

<h3 id="7">可以是两次握手吗</h3>

---

**不可以。**  
当客户端发起一个连接请求时，由于某些原因导致请求在网络中长时间驻留，无法达到服务端，由于 TCP 的超时重传机制，客户端会再次发次一个连接请求，该请求能顺利到达服务端并建立连接，当数据传输完后，释放了 TCP 连接。  
这时若是第一次连接的请求到达了服务端，此时的请求已经是一个失效的报文段了，但是服务端并不知情，接收到连接请求后服务端会再次建立连接，于是服务端发送一个确认应答的消息给客户端，表示同意连接。如果没有第三次握手，由于服务端此时会认为已经建立连接成功，但是客户端并没有发送任何请求和数据，客户端将会忽略掉服务端的确认应答报文。服务端认为建立成功了，并一直等待建立连接，直到超出计数器的设定值，则认为出现了异常并关闭此连接。这个等待的过程浪费了服务端的资源。

<h3 id="8">为什么要 timewait，timewait 有什么缺点</h3>

---

TCP 正常关闭连接时，主动关闭的一方会进入 TIME_WAIT 状态，时间为 2MSL。  
假设最终的 ACK 丢失，对端将重发 FIN，本端必须维护 TCP 状态信息以便可以重发最终的 ACK，否则会发送 RST，结果对端认为发生错误。TCP 实现必须可靠地终止连接的两个方向(全双工关闭)，本端必须进入 TIME_WAIT 状态，因为本端可能面临重发最终 ACK 的情形。  
缺点：  
在高并发短连接的 TCP 服务器上，当服务器完成请求后会正常关闭连接。在这个场景下，会出现大量 socket 处于 TIME_WAIT 的状态下。如果客户端的并发量持续很高，会使服务器端口资源不足而拒绝部分客户端的连接请求。

<h3 id="9">滑动窗口的原理</h3>

---

<h3 id="10">网线断开会发生什么，哪一端会先断开</h3>

---

假如客户端的网线断开，那么服务端并不会知道，如果不主动处理或重启服务的话对于服务端会一直保持着这个连接，永远等不到客户端的任何回应。这种情况就是半开链接，浪费了服务端可用的文件描述符。

<h3 id="11">tcp 最大连接数限制</h3>

---

一条 TCP 连接由四元组（源 IP 地址，源端口，目的 IP 地址，目的端口）构成，理论上改变其中一个值，将得到一条全新的 tcp 连接。
然而实际上最大连接数受限于：

1. Linux 最大可打开文件数（可更改）。
2. 内存限制：一条空的 TCP 连接需要消耗 3.3KB 左右（file、socket 等内核对象）。
3. 如果收发数据，还需要再开启接收（默认 4K）、发送（默认 4K）缓冲区，会增加内存的开销（还会增加 CPU 的负担）。

<h3 id="12">什么是 tcp 粘包，怎么解决</h3>

---

tcp 粘包：tcp 是“流”协议，所谓流协议，就是数据没有界限，没有分割的一串数据。tcp 协议会根据缓冲区实际情况进行划分，一个完整的包可能会拆分成多个包进行发送，也有可能多个小包封装成一个大的数据包发送。  
解决方法：

1. 消息数据定长：每次都发送固定长度的包，长度不足的补充空格，缺点是浪费了部分存储空间和带宽，并且不够灵活。
2. 消息数据约定以某些特殊字符为消息边界。
3. 把消息数据分成消息头（header）和消息体（payload），消息头中带有消息的长度，接收到根据消息头中的长度解析数据。
